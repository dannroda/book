---
title: "dojo.c - Foundation Layer"
description: "The core runtime library that powers all Dojo SDKs across platforms"
---

# dojo.c: The Foundation Layer

[**dojo.c**](https://github.com/dojoengine/dojo.c) is the core runtime library that powers all Dojo SDKs.
Written in Rust, it provides the fundamental building blocks for blockchain interaction, account management, and entity synchronization that work consistently across all platforms.

## Implementation Architecture

Rather than implementing blockchain logic separately in each SDK, all Dojo integrations build on this single foundation:

- **Unity SDK** uses dojo.c via C# P/Invoke
- **JavaScript SDK** uses dojo.c compiled to WebAssembly
- **Unreal Engine** integrates dojo.c through C++ bindings
- **Custom integrations** can use dojo.c directly

This ensures consistent behavior, shared bug fixes, and optimal performance across all platforms.
Implementing in Rust provides the following advantages:

- **Memory Safety**: Eliminates classes of bugs (buffer overflows, use-after-free, etc.)
- **Performance**: Zero-cost abstractions compile to optimal machine code
- **Concurrency**: Safe async/await and threading without data races
- **Ecosystem**: Built on battle-tested Rust libraries (tokio, serde, starknet-rs)
- **Cross-Platform**: Single codebase compiles to all target platforms

```
dojo.c Repository (Rust Implementation)
â”œâ”€â”€ Core Rust Logic (types.rs, utils.rs, constants.rs)
â”œâ”€â”€ Conditional Compilation:
â”‚   â”œâ”€â”€ Native Target â†’ C Bindings (cbindgen)
â”‚   â””â”€â”€ WASM Target â†’ JavaScript Bindings (wasm-bindgen)
â””â”€â”€ Generated Outputs:
    â”œâ”€â”€ libdojo_c.{so,dylib,dll} + dojo.h
    â””â”€â”€ dojo_c.js + dojo_c.wasm
```

The key insight: **two interfaces, one implementation**.
Both C and WASM APIs share identical Rust core logic, ensuring consistency.

The two interfaces are designed for different use cases:

### C Bindings API
**Target**: Native platform integrations, custom SDKs, maximum performance

- **Style**: Procedural C functions with callback-based async operations
- **Use Cases**: Building Unity/Unreal plugins, system-level integrations
- **Memory Management**: Manual with explicit cleanup functions
- **Threading**: Callback-driven with internal runtime management

### WASM JavaScript API
**Target**: Web applications, Node.js, rapid prototyping

- **Style**: Modern async/await with object-oriented design
- **Use Cases**: Browser games, web apps, Node.js backends, testing
- **Memory Management**: Automatic garbage collection
- **Threading**: Promise-based with native async support

## Core Capabilities

Both APIs provide the same core functionality with platform-appropriate interfaces:

### Torii Client Integration
- **Entity Queries**: Fetch world state with powerful filtering and pagination
- **Real-time Subscriptions**: Subscribe to entity changes and events
- **Transaction Monitoring**: Track transaction status and confirmations

### Account Management
- **Controller Accounts**: Session-based accounts with policy-restricted permissions
- **Burner Accounts**: Disposable accounts funded by a master account
- **Direct Accounts**: Full control accounts for advanced use cases

### Asset & Token Operations
- **Token Queries**: Fetch ERC20/721/1155 token information
- **Balance Tracking**: Monitor token balances across accounts
- **Real-time Updates**: Subscribe to token and balance changes

### Event & Message System
- **Event Subscriptions**: Listen to Starknet events and Dojo model changes
- **Message Publishing**: Send messages through the Dojo messaging system
- **Transaction History**: Query historical transactions and events

## Choosing the Right API

| Factor | C Bindings | WASM JavaScript |
|--------|------------|-----------------|
| **Performance** | Maximum | Very Good |
| **Integration Effort** | Higher | Lower |
| **Platform Support** | Native Only | Web + Node.js |
| **Development Speed** | Slower | Faster |
| **Memory Control** | Full | Automatic |
| **Debugging** | Native Tools | Browser DevTools |

### Use Case Decision Guide

**ðŸŽ¯ Choose C Bindings when you need:**
- **Maximum Performance**: Every microsecond matters
- **Native Integration**: Unity plugins, Unreal Engine modules, or desktop applications
- **Platform SDK Development**: Creating bindings for new languages/platforms
- **System-Level Access**: Direct memory control, custom threading models
- **Small Footprint**: Minimal runtime dependencies

**ðŸš€ Choose WASM JavaScript when you need:**
- **Rapid Development**: Prototype quickly with familiar JavaScript patterns
- **Web Applications**: Browser games, web dashboards, React/Vue applications
- **Node.js Backends**: Server-side blockchain integration, bots, APIs
- **Cross-Platform Deployment**: Same code runs in browsers and Node.js
- **Rich Debugging**: Browser DevTools, source maps, hot reload

### Integration Examples

**Unity Integration Example:**
```csharp
[DllImport("libdojo_c", CallingConvention = CallingConvention.Cdecl)]
public static extern ResultToriiClient client_new(CString torii_url, FieldElement world);
```

**Node.js Integration Example:**
```javascript
const { ToriiClient } = require('./pkg/dojo_c');
const client = await new ToriiClient(config);
```

dojo.c provides a rock-solid foundation for Dojo client development.
Whether you use it directly or through a platform SDK, it ensures consistent, reliable blockchain interaction across all environments while providing the flexibility to optimize for your specific platform needs.

## Next Steps

- [Complete C API Reference â†’](./c-bindings)
- [Complete JavaScript API Reference â†’](./wasm-bindings)
